'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getChildEventSubscriber;
/*
 * This is used to extract one children's worth of events from a stream of navigation action events
 *
 * Based on the 'action' events that get fired for this navigation state, this utility will fire
 * focus and blur events for this child
 */
function getChildEventSubscriber(addListener, key) {
  var actionSubscribers = new Set();
  var willFocusSubscribers = new Set();
  var didFocusSubscribers = new Set();
  var willBlurSubscribers = new Set();
  var didBlurSubscribers = new Set();

  var removeAll = function removeAll() {
    [actionSubscribers, willFocusSubscribers, didFocusSubscribers, willBlurSubscribers, didBlurSubscribers].forEach(function (set) {
      return set.clear();
    });

    upstreamSubscribers.forEach(function (subs) {
      return subs && subs.remove();
    });
  };

  var getChildSubscribers = function getChildSubscribers(evtName) {
    switch (evtName) {
      case 'action':
        return actionSubscribers;
      case 'willFocus':
        return willFocusSubscribers;
      case 'didFocus':
        return didFocusSubscribers;
      case 'willBlur':
        return willBlurSubscribers;
      case 'didBlur':
        return didBlurSubscribers;
      default:
        return null;
    }
  };

  var emit = function emit(type, payload) {
    var payloadWithType = _extends({}, payload, { type: type });
    var subscribers = getChildSubscribers(type);
    subscribers && subscribers.forEach(function (subs) {
      subs(payloadWithType);
    });
  };

  // lastEmittedEvent keeps track of focus state for one route. First we assume
  // we are blurred. If we are focused on initialization, the first 'action'
  // event will cause onFocus+willFocus events because we had previously been
  // considered blurred
  var lastEmittedEvent = 'didBlur';

  var upstreamEvents = ['willFocus', 'didFocus', 'willBlur', 'didBlur', 'action'];

  var upstreamSubscribers = upstreamEvents.map(function (eventName) {
    return addListener(eventName, function (payload) {
      var state = payload.state,
          lastState = payload.lastState,
          action = payload.action;

      var lastRoutes = lastState && lastState.routes;
      var routes = state && state.routes;

      var lastFocusKey = lastState && lastState.routes && lastState.routes[lastState.index].key;
      var focusKey = routes && routes[state.index].key;

      var isChildFocused = focusKey === key;
      var lastRoute = lastRoutes && lastRoutes.find(function (route) {
        return route.key === key;
      });
      var newRoute = routes && routes.find(function (route) {
        return route.key === key;
      });
      var childPayload = {
        context: key + ':' + action.type + '_' + (payload.context || 'Root'),
        state: newRoute,
        lastState: lastRoute,
        action: action,
        type: eventName
      };
      var isTransitioning = !!state && state.isTransitioning;

      var previouslyLastEmittedEvent = lastEmittedEvent;

      if (lastEmittedEvent === 'didBlur') {
        // The child is currently blurred. Look for willFocus conditions
        if (eventName === 'willFocus' && isChildFocused) {
          emit(lastEmittedEvent = 'willFocus', childPayload);
        } else if (eventName === 'action' && isChildFocused) {
          emit(lastEmittedEvent = 'willFocus', childPayload);
        }
      }
      if (lastEmittedEvent === 'willFocus') {
        // We are currently mid-focus. Look for didFocus conditions.
        // If state.isTransitioning is false, this child event happens immediately after willFocus
        if (eventName === 'didFocus' && isChildFocused && !isTransitioning) {
          emit(lastEmittedEvent = 'didFocus', childPayload);
        } else if (eventName === 'action' && isChildFocused && !isTransitioning) {
          emit(lastEmittedEvent = 'didFocus', childPayload);
        }
      }

      if (lastEmittedEvent === 'didFocus') {
        // The child is currently focused. Look for blurring events
        if (!isChildFocused) {
          // The child is no longer focused within this navigation state
          emit(lastEmittedEvent = 'willBlur', childPayload);
        } else if (eventName === 'willBlur') {
          // The parent is getting a willBlur event
          emit(lastEmittedEvent = 'willBlur', childPayload);
        } else if (eventName === 'action' && previouslyLastEmittedEvent === 'didFocus') {
          // While focused, pass action events to children for grandchildren focus
          emit('action', childPayload);
        }
      }

      if (lastEmittedEvent === 'willBlur') {
        // The child is mid-blur. Wait for transition to end
        if (eventName === 'action' && !isChildFocused && !isTransitioning) {
          // The child is done blurring because transitioning is over, or isTransitioning
          // never began and didBlur fires immediately after willBlur
          emit(lastEmittedEvent = 'didBlur', childPayload);
        } else if (eventName === 'didBlur') {
          // Pass through the parent didBlur event if it happens
          emit(lastEmittedEvent = 'didBlur', childPayload);
        }
      }

      if (lastEmittedEvent === 'didBlur' && !newRoute) {
        removeAll();
      }
    });
  });

  return {
    addListener: function addListener(eventName, eventHandler) {
      var subscribers = getChildSubscribers(eventName);
      if (!subscribers) {
        throw new Error('Invalid event name "' + eventName + '"');
      }
      subscribers.add(eventHandler);
      var remove = function remove() {
        subscribers.delete(eventHandler);
      };
      return { remove: remove };
    }
  };
}