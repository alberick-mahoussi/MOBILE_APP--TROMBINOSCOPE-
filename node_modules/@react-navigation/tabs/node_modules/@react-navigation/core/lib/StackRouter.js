'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _NavigationActions = require('./NavigationActions');

var _NavigationActions2 = _interopRequireDefault(_NavigationActions);

var _StackActions = require('./StackActions');

var _StackActions2 = _interopRequireDefault(_StackActions);

var _createConfigGetter = require('./createConfigGetter');

var _createConfigGetter2 = _interopRequireDefault(_createConfigGetter);

var _getScreenForRouteName = require('./getScreenForRouteName');

var _getScreenForRouteName2 = _interopRequireDefault(_getScreenForRouteName);

var _StateUtils = require('./StateUtils');

var _StateUtils2 = _interopRequireDefault(_StateUtils);

var _validateRouteConfigMap = require('./validateRouteConfigMap');

var _validateRouteConfigMap2 = _interopRequireDefault(_validateRouteConfigMap);

var _invariant = require('./invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _KeyGenerator = require('./KeyGenerator');

var _pathUtils = require('./pathUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function behavesLikePushAction(action) {
  return action.type === _NavigationActions2.default.NAVIGATE || action.type === _StackActions2.default.PUSH;
}

var defaultActionCreators = function defaultActionCreators(route, navStateKey) {
  return {};
};

function isResetToRootStack(action) {
  return action.type === _StackActions2.default.RESET && action.key === null;
}

exports.default = function (routeConfigs) {
  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // Fail fast on invalid route definitions
  (0, _validateRouteConfigMap2.default)(routeConfigs);

  var childRouters = {};
  var routeNames = Object.keys(routeConfigs);

  // Loop through routes and find child routers
  routeNames.forEach(function (routeName) {
    var screen = (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
    if (screen && screen.router) {
      // If it has a router it's a navigator.
      childRouters[routeName] = screen.router;
    } else {
      // If it doesn't have router it's an ordinary React component.
      childRouters[routeName] = null;
    }
  });

  var initialRouteParams = stackConfig.initialRouteParams;

  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;

  var initialRouteName = stackConfig.initialRouteName || routeNames[0];

  var initialChildRouter = childRouters[initialRouteName];

  function getInitialState(action) {
    var route = {};
    var childRouter = childRouters[action.routeName];

    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName
    if (behavesLikePushAction(action) && childRouter !== undefined) {
      var childState = {};
      // The router is null for normal leaf routes
      if (childRouter !== null) {
        var childAction = action.action || _NavigationActions2.default.init({ params: action.params });
        childState = childRouter.getStateForAction(childAction);
      }
      return {
        key: 'StackRouterRoot',
        isTransitioning: false,
        index: 0,
        routes: [_extends({
          params: action.params
        }, childState, {
          key: action.key || (0, _KeyGenerator.generateKey)(),
          routeName: action.routeName
        })]
      };
    }

    if (initialChildRouter) {
      route = initialChildRouter.getStateForAction(_NavigationActions2.default.navigate({
        routeName: initialRouteName,
        params: initialRouteParams
      }));
    }
    var params = (route.params || action.params || initialRouteParams) && _extends({}, route.params || {}, action.params || {}, initialRouteParams || {});
    var initialRouteKey = stackConfig.initialRouteKey;

    route = _extends({}, route, params ? { params: params } : {}, {
      routeName: initialRouteName,
      key: action.key || initialRouteKey || (0, _KeyGenerator.generateKey)()
    });
    return {
      key: 'StackRouterRoot',
      isTransitioning: false,
      index: 0,
      routes: [route]
    };
  }

  var _createPathParser = (0, _pathUtils.createPathParser)(childRouters, routeConfigs, stackConfig.paths, initialRouteName, initialRouteParams),
      getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,
      _getActionForPathAndParams = _createPathParser.getActionForPathAndParams;

  return {
    childRouters: childRouters,

    getComponentForState: function getComponentForState(state) {
      var activeChildRoute = state.routes[state.index];
      var routeName = activeChildRoute.routeName;

      if (childRouters[routeName]) {
        return childRouters[routeName].getComponentForState(activeChildRoute);
      }
      return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
    },
    getComponentForRouteName: function getComponentForRouteName(routeName) {
      return (0, _getScreenForRouteName2.default)(routeConfigs, routeName);
    },
    getActionCreators: function getActionCreators(route, navStateKey) {
      return _extends({}, getCustomActionCreators(route, navStateKey), {
        pop: function pop(n, params) {
          return _StackActions2.default.pop(_extends({
            n: n
          }, params));
        },
        popToTop: function popToTop(params) {
          return _StackActions2.default.popToTop(params);
        },
        push: function push(routeName, params, action) {
          return _StackActions2.default.push({
            routeName: routeName,
            params: params,
            action: action
          });
        },
        replace: function replace(replaceWith, params, action, newKey) {
          if (typeof replaceWith === 'string') {
            return _StackActions2.default.replace({
              routeName: replaceWith,
              params: params,
              action: action,
              key: route.key,
              newKey: newKey
            });
          }
          (0, _invariant2.default)((typeof replaceWith === 'undefined' ? 'undefined' : _typeof(replaceWith)) === 'object', 'Must replaceWith an object or a string');
          (0, _invariant2.default)(params == null, 'Params must not be provided to .replace() when specifying an object');
          (0, _invariant2.default)(action == null, 'Child action must not be provided to .replace() when specifying an object');
          (0, _invariant2.default)(newKey == null, 'Child action must not be provided to .replace() when specifying an object');
          return _StackActions2.default.replace(replaceWith);
        },
        reset: function reset(actions, index) {
          return _StackActions2.default.reset({
            actions: actions,
            index: index == null ? actions.length - 1 : index,
            key: navStateKey
          });
        },
        dismiss: function dismiss() {
          return _NavigationActions2.default.back({
            key: navStateKey
          });
        }
      });
    },
    getStateForAction: function getStateForAction(action, state) {
      // Set up the initial state if needed
      if (!state) {
        return getInitialState(action);
      }

      if (!isResetToRootStack(action) && action.type !== _NavigationActions2.default.NAVIGATE) {
        var keyIndex = action.key ? _StateUtils2.default.indexOf(state, action.key) : -1;

        // Traverse routes from the top of the stack to the bottom, so the
        // active route has the first opportunity, then the one before it, etc.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = state.routes.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var childRoute = _step.value;

            // If a key is provided and in routes state then let's use that
            // knowledge to skip extra getStateForAction calls on other child
            // routers
            if (keyIndex >= 0 && childRoute.key !== action.key) {
              continue;
            }
            var childRouter = childRouters[childRoute.routeName];
            if (childRouter) {
              var route = childRouter.getStateForAction(action, childRoute);

              if (route === null) {
                return state;
              } else if (route && route !== childRoute) {
                return _StateUtils2.default.replaceAt(state, childRoute.key, route, action.type === _NavigationActions2.default.SET_PARAMS);
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (action.type === _NavigationActions2.default.NAVIGATE) {
        // Traverse routes from the top of the stack to the bottom, so the
        // active route has the first opportunity, then the one before it, etc.
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = state.routes.slice().reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _childRoute = _step2.value;

            var _childRouter = childRouters[_childRoute.routeName];
            var childAction = action.routeName === _childRoute.routeName && action.action ? action.action : action;

            if (_childRouter) {
              var nextRouteState = _childRouter.getStateForAction(childAction, _childRoute);

              if (nextRouteState === null || nextRouteState !== _childRoute) {
                var newState = _StateUtils2.default.replaceAndPrune(state, nextRouteState ? nextRouteState.key : _childRoute.key, nextRouteState ? nextRouteState : _childRoute);
                return _extends({}, newState, {
                  isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning
                });
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      // Handle explicit push navigation action. This must happen after the
      // focused child router has had a chance to handle the action.
      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {
        var _childRouter2 = childRouters[action.routeName];
        var _route = void 0;

        (0, _invariant2.default)(action.type !== _StackActions2.default.PUSH || action.key == null, 'StackRouter does not support key on the push action');

        // Before pushing a new route we first try to find one in the existing route stack
        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md
        var lastRouteIndex = state.routes.findIndex(function (r) {
          if (action.key) {
            return r.key === action.key;
          } else {
            return r.routeName === action.routeName;
          }
        });

        if (action.type !== _StackActions2.default.PUSH && lastRouteIndex !== -1) {
          // If index is unchanged and params are not being set, leave state identity intact
          if (state.index === lastRouteIndex && !action.params) {
            return null;
          }

          // Remove the now unused routes at the tail of the routes array
          var routes = state.routes.slice(0, lastRouteIndex + 1);

          // Apply params if provided, otherwise leave route identity intact
          if (action.params) {
            var _route2 = state.routes[lastRouteIndex];
            routes[lastRouteIndex] = _extends({}, _route2, {
              params: _extends({}, _route2.params, action.params)
            });
          }
          // Return state with new index. Change isTransitioning only if index has changed
          return _extends({}, state, {
            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,
            index: lastRouteIndex,
            routes: routes
          });
        }

        if (_childRouter2) {
          var _childAction = action.action || _NavigationActions2.default.init({ params: action.params });
          _route = _extends({
            params: action.params
          }, _childRouter2.getStateForAction(_childAction), {
            routeName: action.routeName,
            key: action.key || (0, _KeyGenerator.generateKey)()
          });
        } else {
          _route = {
            params: action.params,
            routeName: action.routeName,
            key: action.key || (0, _KeyGenerator.generateKey)()
          };
        }
        return _extends({}, _StateUtils2.default.push(state, _route), {
          isTransitioning: action.immediate !== true
        });
      } else if (action.type === _StackActions2.default.PUSH && childRouters[action.routeName] === undefined) {
        // Return the state identity to bubble the action up
        return state;
      }

      // Handle navigation to other child routers that are not yet pushed
      if (behavesLikePushAction(action)) {
        var childRouterNames = Object.keys(childRouters);
        for (var i = 0; i < childRouterNames.length; i++) {
          var childRouterName = childRouterNames[i];
          var _childRouter3 = childRouters[childRouterName];
          if (_childRouter3) {
            // For each child router, start with a blank state
            var initChildRoute = _childRouter3.getStateForAction(_NavigationActions2.default.init());
            // Then check to see if the router handles our navigate action
            var navigatedChildRoute = _childRouter3.getStateForAction(action, initChildRoute);
            var routeToPush = null;
            if (navigatedChildRoute === null) {
              // Push the route if the router has 'handled' the action and returned null
              routeToPush = initChildRoute;
            } else if (navigatedChildRoute !== initChildRoute) {
              // Push the route if the state has changed in response to this navigation
              routeToPush = navigatedChildRoute;
            }
            if (routeToPush) {
              var _route3 = _extends({}, routeToPush, {
                routeName: childRouterName,
                key: action.key || (0, _KeyGenerator.generateKey)()
              });
              return _extends({}, _StateUtils2.default.push(state, _route3), {
                isTransitioning: action.immediate !== true
              });
            }
          }
        }
      }

      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.
      if (action.type === _StackActions2.default.POP_TO_TOP) {
        // Refuse to handle pop to top if a key is given that doesn't correspond
        // to this router
        if (action.key && state.key !== action.key) {
          return state;
        }

        // If we're already at the top, then we return the state with a new
        // identity so that the action is handled by this router.
        if (state.index > 0) {
          return _extends({}, state, {
            isTransitioning: action.immediate !== true,
            index: 0,
            routes: [state.routes[0]]
          });
        }
        return state;
      }

      // Handle replace action
      if (action.type === _StackActions2.default.REPLACE) {
        var routeIndex = state.routes.findIndex(function (r) {
          return r.key === action.key;
        });
        // Only replace if the key matches one of our routes
        if (routeIndex !== -1) {
          var _childRouter4 = childRouters[action.routeName];
          var childState = {};
          if (_childRouter4) {
            var _childAction2 = action.action || _NavigationActions2.default.init({ params: action.params });
            childState = _childRouter4.getStateForAction(_childAction2);
          }
          var _routes = [].concat(_toConsumableArray(state.routes));
          _routes[routeIndex] = _extends({
            params: action.params
          }, childState, {
            routeName: action.routeName,
            key: action.newKey || (0, _KeyGenerator.generateKey)()
          });
          return _extends({}, state, { routes: _routes });
        }
      }

      // Update transitioning state
      if (action.type === _StackActions2.default.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {
        return _extends({}, state, {
          isTransitioning: false
        });
      }

      if (action.type === _NavigationActions2.default.SET_PARAMS) {
        var key = action.key;
        var lastRoute = state.routes.find(function (route) {
          return route.key === key;
        });
        if (lastRoute) {
          var params = _extends({}, lastRoute.params, action.params);
          var _routes2 = [].concat(_toConsumableArray(state.routes));
          _routes2[state.routes.indexOf(lastRoute)] = _extends({}, lastRoute, {
            params: params
          });
          return _extends({}, state, {
            routes: _routes2
          });
        }
      }

      if (action.type === _StackActions2.default.RESET) {
        // Only handle reset actions that are unspecified or match this state key
        if (action.key != null && action.key != state.key) {
          // Deliberately use != instead of !== so we can match null with
          // undefined on either the state or the action
          return state;
        }
        var newStackActions = action.actions;

        return _extends({}, state, {
          routes: newStackActions.map(function (newStackAction) {
            var router = childRouters[newStackAction.routeName];

            var childState = {};

            if (router) {
              var _childAction3 = newStackAction.action || _NavigationActions2.default.init({ params: newStackAction.params });

              childState = router.getStateForAction(_childAction3);
            }

            return _extends({
              params: newStackAction.params
            }, childState, {
              routeName: newStackAction.routeName,
              key: newStackAction.key || (0, _KeyGenerator.generateKey)()
            });
          }),
          index: action.index
        });
      }

      if (action.type === _NavigationActions2.default.BACK || action.type === _StackActions2.default.POP) {
        var _key = action.key,
            n = action.n,
            immediate = action.immediate;

        var backRouteIndex = state.index;
        if (action.type === _StackActions2.default.POP && n != null) {
          // determine the index to go back *from*. In this case, n=1 means to go
          // back from state.index, as if it were a normal "BACK" action
          backRouteIndex = Math.max(1, state.index - n + 1);
        } else if (_key) {
          var backRoute = state.routes.find(function (route) {
            return route.key === _key;
          });
          backRouteIndex = state.routes.indexOf(backRoute);
        }

        if (backRouteIndex > 0) {
          return _extends({}, state, {
            routes: state.routes.slice(0, backRouteIndex),
            index: backRouteIndex - 1,
            isTransitioning: immediate !== true
          });
        }
      }

      return state;
    },
    getPathAndParamsForState: function getPathAndParamsForState(state) {
      var route = state.routes[state.index];
      return getPathAndParamsForRoute(route);
    },
    getActionForPathAndParams: function getActionForPathAndParams(path, params) {
      return _getActionForPathAndParams(path, params);
    },


    getScreenOptions: (0, _createConfigGetter2.default)(routeConfigs, stackConfig.navigationOptions)
  };
};